<?xml version="1.0"?>
<doc>
    <assembly>
        <name>VRage.Render</name>
    </assembly>
    <members>
        <member name="T:VRageRender.Animations.MyAnimationTreeNode">
            <summary>
            Interface representing one node in animation tree.
            </summary>
        </member>
        <member name="T:VRageRender.Animations.MyAnimationTreeNodeDummy">
            <summary>
            Node of animation tree: single track. Contains reference to animation clip.
            </summary>
        </member>
        <member name="T:VRageRender.Animations.MyAnimationTreeNodeMix1D">
            <summary>
            Mixing between animation nodes on 1D axis.
            </summary>
        </member>
        <member name="T:VRageRender.Animations.MyAnimationTreeNodeTrack">
            <summary>
            Node of animation tree: single track. Contains reference to animation clip.
            </summary>
        </member>
        <member name="M:VRageRender.Animations.MyAnimationTreeNodeTrack.ProcessLayerTimeSync(VRageRender.Animations.MyAnimationUpdateData@)">
            <summary>
            Synchronize time with defined layer. Returns false if the time is not synchronized.
            </summary>
        </member>
        <member name="T:VRageRender.Animations.MyAnimationVariableStorage">
            <summary>
            Key-value storage of float values, other types are implicitly converted.
            </summary>
        </member>
        <member name="T:VRageRender.Animations.MyAnimationVariableStorageHints">
            <summary>
            Variable storage - Hints for the user, common variable names, descriptions, string ids.
            </summary>
        </member>
        <member name="F:VRageRender.Animations.MyAnimationVariableStorageHints.MyVariableNameHint.Name">
            <summary>
            Variable name.
            </summary>
        </member>
        <member name="F:VRageRender.Animations.MyAnimationVariableStorageHints.MyVariableNameHint.Hint">
            <summary>
            Description of the variable.
            </summary>
        </member>
        <member name="T:VRageRender.Animations.ModelAnimations">
            <summary>
            Class that contains additional information attached to the model and
            shared with the runtime.
            </summary>
        </member>
        <member name="F:VRageRender.Animations.ModelAnimations.skeleton">
            <summary>
            The bone indices for the skeleton associated with any
            skinned model.
            </summary>
        </member>
        <member name="F:VRageRender.Animations.ModelAnimations.clips">
            <summary>
            Any associated animation clips
            </summary>
        </member>
        <member name="P:VRageRender.Animations.ModelAnimations.Skeleton">
            <summary>
            The bone indices for the skeleton associated with any
            skinned model.
            </summary>
        </member>
        <member name="P:VRageRender.Animations.ModelAnimations.Clips">
            <summary>
            Animation clips associated with this model
            </summary>
        </member>
        <member name="T:VRageRender.Animations.MyAnimationClip">
            <summary>
            An animation clip is a set of keyframes with associated bones.
            VRAGE TODO: Any link to actual animation collection? Or at least to rest pose? Please?
            </summary>
        </member>
        <member name="F:VRageRender.Animations.MyAnimationClip.bones">
            <summary>
            The bones for this animation
            </summary>
        </member>
        <member name="F:VRageRender.Animations.MyAnimationClip.Name">
            <summary>
            Name of the animation clip
            </summary>
        </member>
        <member name="F:VRageRender.Animations.MyAnimationClip.Duration">
            <summary>
            Duration of the animation clip
            </summary>
        </member>
        <member name="P:VRageRender.Animations.MyAnimationClip.Bones">
            <summary>
            The bones for this animation clip with their keyframes
            </summary>
        </member>
        <member name="T:VRageRender.Animations.MyAnimationClip.BoneState">
            <summary>
            BoneState is a rotation and translation of the bone.
            It would be easy to extend this to include scaling as well.
            </summary>
        </member>
        <member name="T:VRageRender.Animations.MyAnimationClip.Keyframe">
            <summary>
            An Keyframe extends rotation and translation of the bone by specifying time of the event.
            </summary>
            Beware, this class is used also in MWM builder and changing it to struct may cause problems during MWM generation.
        </member>
        <member name="T:VRageRender.Animations.MyAnimationClip.Bone">
            <summary>
            Keyframes are grouped per bone for an animation clip
            </summary>
        </member>
        <member name="F:VRageRender.Animations.MyAnimationClip.Bone.m_name">
            <summary>
            Each bone has a name so we can associate it with a runtime model
            </summary>
        </member>
        <member name="F:VRageRender.Animations.MyAnimationClip.Bone.m_keyframes">
            <summary>
            The keyframes for this bone
            </summary>
        </member>
        <member name="P:VRageRender.Animations.MyAnimationClip.Bone.Name">
            <summary>
            The bone name for these keyframes
            </summary>
        </member>
        <member name="P:VRageRender.Animations.MyAnimationClip.Bone.Keyframes">
            <summary>
            The keyframes for this bone
            </summary>
        </member>
        <member name="T:VRageRender.Animations.MyAnimationController">
            <summary>
            Animation controller contains and drives skeletal animations.
            It also serves as an abstraction layer, hiding low/level classes.
            </summary>
        </member>
        <member name="M:VRageRender.Animations.MyAnimationController.CreateLayer(System.String,System.Int32)">
            <summary>
            Create animation layer with unique name. Parameter insertionIndex can be left -1 to add the layer at the end.
            If layer with same name is already present, method fails and returns null.
            </summary>
        </member>
        <member name="M:VRageRender.Animations.MyAnimationController.Update(VRageRender.Animations.MyAnimationUpdateData@)">
            <summary>
            Update this animation controller.
            </summary>
            <param name="animationUpdateData">See commentary in MyAnimationUpdateData</param>
        </member>
        <member name="M:VRageRender.Animations.MyAnimationController.TriggerAction(VRage.Utils.MyStringId)">
            <summary>
            Trigger an action in all layers. 
            If there is a transition having given (non-null) name, it is followed immediatelly.
            Conditions of transition are ignored.
            </summary>
        </member>
        <member name="M:VRageRender.Animations.MyAnimationController.UpdateInverseKinematics(VRageRender.Animations.MyCharacterBone[]@)">
            <summary>
            Perform inverse kinematics.
            </summary>
        </member>
        <member name="T:VRageRender.Animations.MyAnimationController.MyResultBonesPool">
            <summary>
            Simple pool allocator for bone results.
            </summary>
        </member>
        <member name="M:VRageRender.Animations.MyAnimationController.MyResultBonesPool.Reset(VRageRender.Animations.MyCharacterBone[])">
            <summary>
            Set the new bone count and default (rest) pose.
            </summary>
        </member>
        <member name="M:VRageRender.Animations.MyAnimationController.MyResultBonesPool.SetDefaultPose(System.Collections.Generic.List{VRageRender.Animations.MyAnimationClip.BoneState})">
            <summary>
            Set the link to default pose = default bone positions and rotations given when using this allocator.
            If null is given, rest pose is used.
            </summary>
        </member>
        <member name="M:VRageRender.Animations.MyAnimationController.MyResultBonesPool.Alloc">
            <summary>
            Allocate array of bones from pool. Bones are in the rest (bind) position by default.
            </summary>
            <returns></returns>
        </member>
        <member name="T:VRageRender.Animations.IMyTerrainHeightProvider">
            <summary>
            Interface providing terrain height in model space.
            </summary>
        </member>
        <member name="M:VRageRender.Animations.IMyTerrainHeightProvider.GetTerrainHeight(VRageMath.Vector3,VRageMath.Vector3,System.Single@,VRageMath.Vector3@)">
            <summary>
            Get terrain height in model space.
            </summary>
            <param name="bonePosition">bone position in model space</param>
            <param name="boneRigPosition">bone rig position in model space</param>
            <param name="terrainHeight">terrain height in model space</param>
            <param name="terrainNormal">terrain normal in (character) model space</param>
            <returns>true if the intersection was found</returns>
        </member>
        <member name="M:VRageRender.Animations.IMyTerrainHeightProvider.GetReferenceTerrainHeight">
            <summary>
            Get reference terrain height - (flat terrain height) in model space.
            </summary>
        </member>
        <member name="T:VRageRender.Animations.MyAnimationIkChain">
            <summary>
            Tiny structure describing IK chain.
            </summary>
        </member>
        <member name="T:VRageRender.Animations.MyAnimationIkChainExt">
            <summary>
            Tiny structure describing IK chain + remembering last state.
            </summary>
        </member>
        <member name="M:VRageRender.Animations.MyAnimationIkChainExt.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:VRageRender.Animations.MyAnimationIkChainExt.#ctor(VRageRender.Animations.MyAnimationIkChain)">
            <summary>
            Copy constructor.
            </summary>
        </member>
        <member name="T:VRageRender.Animations.MyAnimationInverseKinematics">
            <summary>
            Class providing various IK solutions.
            Feet IK is 
            </summary>
        </member>
        <member name="F:VRageRender.Animations.MyAnimationInverseKinematics.m_characterDirDownOffsetMin">
            <summary>
            Maximum character offsets.
            </summary>
        </member>
        <member name="F:VRageRender.Animations.MyAnimationInverseKinematics.m_feet">
            <summary>
            List of all feet bones.
            </summary>
        </member>
        <member name="F:VRageRender.Animations.MyAnimationInverseKinematics.m_ignoredBonesTable">
            <summary>
            List of all ignored bones (that should not move during IK!).
            </summary>
        </member>
        <member name="F:VRageRender.Animations.MyAnimationInverseKinematics.m_ignoredBoneNames">
            <summary>
            All ignored bones (that should not move during IK!). Names of ignored bones.
            </summary>
        </member>
        <member name="F:VRageRender.Animations.MyAnimationInverseKinematics.m_characterDirDownOffset">
            <summary>
            Character offset - used when the character is slightly above the terrain due to the capsule
            </summary>
        </member>
        <member name="F:VRageRender.Animations.MyAnimationInverseKinematics.m_characterDirDownOffsetSmoothness">
            <summary>
            Character offset smoothing.
            </summary>
        </member>
        <member name="F:VRageRender.Animations.MyAnimationInverseKinematics.m_currentFeetIkInfluence">
            <summary>
            Current influence of the feet IK.
            </summary>
        </member>
        <member name="M:VRageRender.Animations.MyAnimationInverseKinematics.ResetIkInfluence">
            <summary>
            Immediatelly reset the IK influence to zero.
            </summary>
        </member>
        <member name="M:VRageRender.Animations.MyAnimationInverseKinematics.SolveFeet(System.Boolean,VRageRender.Animations.MyCharacterBone[],System.Boolean)">
            <summary>
            Solve feet positions. 
            </summary>
            <param name="enabled">Feet resolving is enabled - this is a parameter because of blending over time.</param>
            <param name="characterBones">Character bones storage.</param>
            <param name="allowMovingWithBody">If feet cannot reach, move the body</param>
        </member>
        <member name="M:VRageRender.Animations.MyAnimationInverseKinematics.SolveIkTwoBones(VRageRender.Animations.MyCharacterBone[],VRageRender.Animations.MyAnimationIkChainExt,VRageMath.Vector3@,VRageMath.Vector3@,System.Boolean)">
            <summary>
            Solve IK for chain of two bones + change rotation of end bone.
            </summary>
            <param name="characterBones">bone storage</param>
            <param name="ikChain">description of bone chain</param>
            <param name="finalPosition">desired position of end bone</param>
            <param name="finalNormal">desired normal of end bone - would be projected on plane first bone-second bone-third bone</param>
            <param name="fromBindPose">solve this starting from the bind pose</param>
            <returns>true on success</returns>
        </member>
        <member name="M:VRageRender.Animations.MyAnimationInverseKinematics.RegisterFootBone(System.String,System.Int32,System.Boolean)">
            <summary>
            Register foot IK bone chain.
            </summary>
        </member>
        <member name="M:VRageRender.Animations.MyAnimationInverseKinematics.RegisterIgnoredBone(System.String)">
            <summary>
            Register bone ignored by IK. IK will not move it.
            </summary>
        </member>
        <member name="P:VRageRender.Animations.MyAnimationInverseKinematics.Feet">
            <summary>
            List of all feet bones.
            </summary>
        </member>
        <member name="P:VRageRender.Animations.MyAnimationInverseKinematics.TerrainHeightProvider">
            <summary>
            Interface providing results from raycasts.
            </summary>
        </member>
        <member name="T:VRageRender.Animations.MyAnimationStateMachine">
            <summary>
            Animation state machine selects the animation to match current state.
            When it finds valid transition to some next state, transition is performed automatically.
            </summary>
        </member>
        <member name="M:VRageRender.Animations.MyAnimationStateMachine.ComputeEaseInEaseOut(System.Single,VRageRender.Animations.MyAnimationTransitionCurve)">
            <summary>
            Computing transition weight from the normalized time.
            </summary>
            <param name="t">normalized remaining time of the animation that is being phased out, going from 1 to 0</param>
            <param name="curve">used transition curve</param>
            <returns>weight of the animation that is being phased out, 1 to 0</returns>
        </member>
        <member name="T:VRageRender.Animations.MyAnimationStateMachineNode">
            <summary>
            Animation state machine node is a representation of one state inside MyAnimationStateMachine.
            </summary>
        </member>
        <member name="T:VRageRender.Animations.MyAnimationTransitionCurve">
            <summary>
            Transition mixing curve type.
            </summary>
        </member>
        <member name="F:VRageRender.Animations.MyAnimationTransitionCurve.Smooth">
            <summary>
            Smooth transition (smooth step).
            </summary>
        </member>
        <member name="F:VRageRender.Animations.MyAnimationTransitionCurve.EaseIn">
            <summary>
            Ease in (cubic function).
            </summary>
        </member>
        <member name="T:VRageRender.Animations.MyAnimationStateMachineTransition">
            <summary>
            Description of transition to another state (MyAnimationStateMachineNode) in the state machine (MyAnimationStateMachine).
            </summary>
        </member>
        <member name="M:VRageRender.Animations.MyAnimationStateMachineTransition.Evaluate">
            <summary>
            Animation transition evaluation - different behavior from default transition. 
            If no conditions are given and it has a name, it must be triggered manually.
            
            </summary>
        </member>
        <member name="T:VRageRender.Animations.MyAnimationUpdateData">
            <summary>
            Helper structure passed as an parameter during computation of current pose.
            </summary>
        </member>
        <member name="T:VRageRender.Animations.MyCharacterBone">
            <summary>
            Bones in this model are represented by this class, which
            allows a bone to have more detail associatd with it.
            
            This class allows you to manipulate the local coordinate system
            for objects by changing the scaling, translation, and rotation.
            These are indepenent of the bind transformation originally supplied
            for the model. So, the actual transformation for a bone is
            the product of the:
            
            Scaling
            Bind scaling (scaling removed from the bind transform)
            Rotation
            Translation
            Bind Transformation
            Parent Absolute Transformation
            
            </summary>
        </member>
        <member name="F:VRageRender.Animations.MyCharacterBone.m_parent">
            <summary>
            Any parent for this bone
            </summary>
        </member>
        <member name="F:VRageRender.Animations.MyCharacterBone.m_bindTransform">
            <summary>
            The bind transform is the transform for this bone
            as loaded from the original model. It's the base pose.
            I do remove any scaling, though.
            </summary>
        </member>
        <member name="F:VRageRender.Animations.MyCharacterBone.m_translation">
            <summary>
            Any translation applied to the bone
            </summary>
        </member>
        <member name="F:VRageRender.Animations.MyCharacterBone.m_rotation">
            <summary>
            Any rotation applied to the bone
            </summary>
        </member>
        <member name="F:VRageRender.Animations.MyCharacterBone.m_changed">
            <summary>
            indicates whether bone needs recalculation
            </summary>
        </member>
        <member name="F:VRageRender.Animations.MyCharacterBone.Name">
            <summary>
            The bone name
            </summary>
        </member>
        <member name="M:VRageRender.Animations.MyCharacterBone.#ctor(System.String,VRageRender.Animations.MyCharacterBone,VRageMath.Matrix,System.Int32,VRageMath.Matrix[],VRageMath.Matrix[])">
            <summary>
            Constructor for a bone object
            </summary>
            <param name="name">The name of the bone</param>
            <param name="bindTransform">The initial bind transform for the bone</param>
            <param name="parent">A parent for this bone</param>
            <param name="index">Index of this bone in storage arrays.</param>
            <param name="relativeStorage">reference to matrix array storing all relative transforms of the skeleton</param>
            <param name="absoluteStorage">reference to matrix array storing all absolute transforms of the skeleton</param>
        </member>
        <member name="M:VRageRender.Animations.MyCharacterBone.ComputeAbsoluteTransforms(VRageRender.Animations.MyCharacterBone[])">
            <summary>
            Compute absolute bone transforms for whole hierarchy.
            Expects the array to be sorted by depth in hiearachy.
            </summary>
        </member>
        <member name="M:VRageRender.Animations.MyCharacterBone.TranslateAllBones(VRageRender.Animations.MyCharacterBone[],VRageMath.Vector3)">
            <summary>
            Translate all bones. Translation vector is given in model space. 
            We expect that absolute transforms are already computed.
            </summary>
        </member>
        <member name="M:VRageRender.Animations.MyCharacterBone.ComputeAbsoluteTransform(System.Boolean)">
            <summary>
            Compute the absolute transformation for this bone.
            </summary>
        </member>
        <member name="M:VRageRender.Animations.MyCharacterBone.SetCompleteTransform(VRageMath.Vector3@,VRageMath.Quaternion@,System.Single)">
            <summary>
            This sets the rotation and translation such that the
            rotation times the translation times the bind after set
            equals this matrix. This is used to set animation values.
            </summary>
        </member>
        <member name="M:VRageRender.Animations.MyCharacterBone.SetCompleteBindTransform">
            <summary>
            This sets the rotation and translation of the rest pose.
            </summary>
        </member>
        <member name="M:VRageRender.Animations.MyCharacterBone.SetCompleteTransform(VRageMath.Vector3@,VRageMath.Quaternion@)">
            <summary>
            This sets the rotation and translation such that the
            rotation times the translation times the bind after set
            equals this matrix. This is used to set animation values.
            </summary>
        </member>
        <member name="M:VRageRender.Animations.MyCharacterBone.SetCompleteTransformFromAbsoluteMatrix(VRageMath.Matrix@,System.Boolean)">
            <summary>
            Set the rotation and translation of the bone from absolute transform. Does not recompute hierarchy - call ComputeAbsoluteTransform.
            </summary>
            <param name="absoluteMatrix">absolute transform</param>
            <param name="onlyRotation">apply only rotation</param>
        </member>
        <member name="M:VRageRender.Animations.MyCharacterBone.SetCompleteTransformFromAbsoluteMatrix(VRageMath.Matrix,System.Boolean)">
            <summary>
            Set the rotation and translation of the bone from absolute transform. Does not recompute hierarchy - call ComputeAbsoluteTransform.
            </summary>
            <param name="absoluteMatrix">absolute transform</param>
            <param name="onlyRotation">apply only rotation</param>
        </member>
        <member name="M:VRageRender.Animations.MyCharacterBone.SetCompleteRotation(VRageMath.Quaternion@)">
            <summary>
            This adds the rotation and translation to the one that is already set inside.
            </summary>
        </member>
        <member name="M:VRageRender.Animations.MyCharacterBone.GetCompleteTransform(VRageMath.Vector3@,VRageMath.Quaternion@,VRageMath.Vector3@,VRageMath.Quaternion@)">
            <summary>
            Same as SetCompleteTransform, but result is not stored internally, it is returned instead.
            </summary>
        </member>
        <member name="M:VRageRender.Animations.MyCharacterBone.GetAbsoluteRigTransform">
            <summary>
            Returns bone's rig absolute transform - including transforms of all parent bones
            </summary>
            <returns></returns>
        </member>
        <member name="P:VRageRender.Animations.MyCharacterBone.BindTransform">
            <summary>
            The bone bind transform
            </summary>
        </member>
        <member name="P:VRageRender.Animations.MyCharacterBone.SkinTransform">
            <summary>
            Inverse of absolute bind transform for skinnning
            </summary>
        </member>
        <member name="P:VRageRender.Animations.MyCharacterBone.Rotation">
            <summary>
            Bone rotation
            </summary>
        </member>
        <member name="P:VRageRender.Animations.MyCharacterBone.Translation">
            <summary>
            Any translations
            </summary>
        </member>
        <member name="P:VRageRender.Animations.MyCharacterBone.Parent">
            <summary>
            The parent bone or null for the root bone
            </summary>
        </member>
        <member name="P:VRageRender.Animations.MyCharacterBone.AbsoluteTransform">
            <summary>
            The bone absolute transform
            </summary>
        </member>
        <member name="P:VRageRender.Animations.MyCharacterBone.RelativeTransform">
            <summary>
            The bone absolute transform
            </summary>
        </member>
        <member name="P:VRageRender.Animations.MyCharacterBone.HasThisOrAnyParentChanged">
            <summary>
            Has this bone or any parent bone changed?
            </summary>
        </member>
        <member name="M:VRageRender.ExternalApp.IMyBufferedInputSource.SwapBufferedTextInput(System.Collections.Generic.List{System.Char}@)">
            <summary>
            Swaps internal buffer with the one passed as argument. This swapping operation
            must be implemented in a thread safe manner. Buffer passed into the function will
            replaced by the internal buffer and returned in the same variable.
            </summary>
        </member>
        <member name="M:VRageRender.ExternalApp.IMyRenderWindow.OnModeChanged(VRageRender.MyWindowModeEnum,System.Int32,System.Int32,VRageMath.Rectangle)">
            <summary>
            Called by render when display mode has changed
            </summary>
        </member>
        <member name="P:VRageRender.ExternalApp.IMyRenderWindow.DrawEnabled">
            <summary>
            True when Present on device should be called (e.g. window not minimized)
            </summary>
        </member>
        <member name="P:VRageRender.ExternalApp.IMyRenderWindow.Handle">
            <summary>
            Target window handle
            </summary>
        </member>
        <member name="M:VRageRender.ExternalApp.MyGameRenderComponent.Start(VRage.Library.Utils.MyGameTimer,VRageRender.ExternalApp.InitHandler,System.Nullable{VRageRender.MyRenderDeviceSettings},VRageRender.MyRenderQualityEnum,System.Single)">
            <summary>
            Creates and starts render thread
            </summary>
        </member>
        <member name="M:VRageRender.ExternalApp.MyGameRenderComponent.Stop">
            <summary>
            Stops and clears render thread
            </summary>
        </member>
        <member name="T:VRageRender.ExternalApp.InitHandler">
            <summary>
            Initializes window on render thread and returns it's handle of window/control where to draw
            </summary>
        </member>
        <member name="M:VRageRender.ExternalApp.MyRenderThread.Exit">
            <summary>
            Signals the thread to exit and waits until it does so
            </summary>
        </member>
        <member name="T:VRageRender.Fractures.WoodFractureSettings.Rotation">
            How to rotate the splitting geometry
        </member>
        <member name="M:VRageRender.Import.ModelAutoRebuild.IsModelActual(System.String,System.String,System.String,System.String)">
            <summary>
            Checks whether that model file was build with current sources files. If current sources of this model - FBX, XML, HKT etc. were changed, this returns false.
            </summary>
            <param name="modelFile"></param>
            <returns>true - if data hashes of source files are valid </returns>
            <returns>false - if data has been changed</returns>
        </member>
        <member name="P:VRageRender.Import.MyMeshSectionMeshInfo.StartIndex">
            <summary>Offset in index list</summary>
        </member>
        <member name="P:VRageRender.Import.MyMeshSectionMeshInfo.IndexCount">
            <summary>Offset in index list</summary>
        </member>
        <member name="M:VRageRender.Import.MyLODDescriptor.GetModelAbsoluteFilePath(System.String)">
            <summary>
            Absolute file path to the LOD model related to the parent assetFilePath.
            </summary>
            <param name="parentAssetFilePath">File path of parent asset.</param>
            <returns>Absolute file path.</returns>
        </member>
        <member name="T:VRageRender.Import.MyMaterialDescriptor">
            <summary>
            material params for export
            </summary>
        </member>
        <member name="M:VRageRender.Import.MyMaterialDescriptor.#ctor(System.String)">
            <summary>
            c-tor
            </summary>
            <param name="materialName"></param>
        </member>
        <member name="M:VRageRender.Import.MyMaterialDescriptor.Write(System.IO.BinaryWriter)">
            <summary>
            Write to binary file
            </summary>
            <param name="writer"></param>
            <returns></returns>
        </member>
        <member name="F:VRageRender.Import.Mesh.VertexOffset">
            <summary>
            Offset on the vertex buffer
            </summary>
        </member>
        <member name="F:VRageRender.Import.Mesh.StartIndex">
            <summary>
            Offset on the indices buffer
            </summary>
        </member>
        <member name="M:VRageRender.Import.MyModelExporter.#ctor(System.String)">
            <summary>
            c-tor
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="M:VRageRender.Import.MyModelExporter.#ctor">
            <summary>
            c-tor
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="M:VRageRender.Import.MyModelExporter.Dispose">
            <summary>
            Close
            </summary>
        </member>
        <member name="M:VRageRender.Import.MyModelExporter.WriteTag(System.String)">
            <summary>
            WriteTag
            </summary>
            <param name="tagName"></param>
        </member>
        <member name="M:VRageRender.Import.MyModelExporter.WriteVector(VRageMath.Vector2)">
            <summary>
            WriteVector2
            </summary>
            <param name="vct"></param>
        </member>
        <member name="M:VRageRender.Import.MyModelExporter.WriteVector(VRageMath.Vector3)">
            <summary>
            WriteVector3
            </summary>
            <param name="vct"></param>
        </member>
        <member name="M:VRageRender.Import.MyModelExporter.WriteVector(VRageMath.Vector4)">
            <summary>
            WriteVector4
            </summary>
            <param name="vct"></param>
        </member>
        <member name="M:VRageRender.Import.MyModelExporter.WriteMatrix(VRageMath.Matrix)">
            <summary>
            WriteMatrix
            </summary>
            <param name="matrix"></param>
        </member>
        <member name="M:VRageRender.Import.MyModelExporter.WriteVector(VRageMath.Vector2I)">
            <summary>
            WriteVector2
            </summary>
            <param name="vct"></param>
        </member>
        <member name="M:VRageRender.Import.MyModelExporter.WriteVector(VRageMath.Vector3I)">
            <summary>
            WriteVector3
            </summary>
            <param name="vct"></param>
        </member>
        <member name="M:VRageRender.Import.MyModelExporter.WriteVector(VRageMath.Vector4I)">
            <summary>
            WriteVector4
            </summary>
            <param name="vct"></param>
        </member>
        <member name="M:VRageRender.Import.MyModelExporter.WriteByte4(VRageMath.PackedVector.Byte4)">
            <summary>
            Write Byte4
            </summary>
        </member>
        <member name="M:VRageRender.Import.MyModelExporter.ExportData(System.String,VRageMath.Vector3[])">
            <summary>
            ExportData
            </summary>
            <param name="tagName"></param>
            <param name="vctArray"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelExporter.ExportData(System.String,VRageMath.Matrix[])">
            <summary>
            ExportData
            </summary>
            <param name="tagName"></param>
            <param name="vctArray"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelExporter.ExportData(System.String,VRageMath.Vector2[])">
            <summary>
            ExportData
            </summary>
            <param name="tagName"></param>
            <param name="vctArray"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelExporter.ExportData(System.String,VRageMath.Vector4[])">
            <summary>
            ExportData
            </summary>
            <param name="tagName"></param>
            <param name="strArr"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelExporter.ExportData(System.String,System.String[])">
            <summary>
            ExportData
            </summary>
            <param name="tagName"></param>
            <param name="strArr"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelExporter.ExportData(System.String,System.Int32[])">
            <summary>
            ExportData
            </summary>
            <param name="tagName"></param>
            <param name="strArr"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelExporter.ExportData(System.String,System.Byte[])">
            <summary>
            ExportData
            </summary>
            <param name="tagName"></param>
            <param name="strArr"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelExporter.ExportData(System.String,VRageRender.Import.MyModelInfo)">
            <summary>
            ExportData
            </summary>
            <param name="tagName"></param>
            <param name="strArr"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelExporter.ExportData(System.String,VRageMath.BoundingBox)">
            <summary>
            ExportData
            </summary>
            <param name="tagName"></param>
            <param name="strArr"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelExporter.ExportData(System.String,VRageMath.BoundingSphere)">
            <summary>
            ExportData
            </summary>
            <param name="tagName"></param>
            <param name="strArr"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelExporter.ExportData(System.String,System.Collections.Generic.Dictionary{System.String,VRageMath.Matrix})">
            <summary>
            ExportData
            </summary>
            <param name="tagName"></param>
            <param name="dict"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelExporter.ExportData(System.String,System.Collections.Generic.List{VRageRender.Import.MyMeshPartInfo})">
            <summary>
            ExportData
            </summary>
            <param name="tagName"></param>
            <param name="dict"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelExporter.ExportData(System.String,System.Collections.Generic.Dictionary{System.String,VRageRender.Import.MyModelDummy})">
            <summary>
            ExportData
            </summary>
            <param name="tagName"></param>
            <param name="dict"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelExporter.ExportFloat(System.String,System.Single)">
            <summary>
            ExportFloat
            </summary>
            <param name="tagName"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelExporter.ExportBool(System.String,System.Boolean)">
            <summary>
            ExportFloat
            </summary>
            <param name="tagName"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelExporter.WriteQuaternion(VRageMath.Quaternion)">
            <summary>
            WriteQuaternion
            </summary>
            <param name="vct"></param>
        </member>
        <member name="M:VRageRender.Import.MyModelImporter.ReadVector3(System.IO.BinaryReader)">
            <summary>
            Read Vector34
            </summary>
        </member>
        <member name="M:VRageRender.Import.MyModelImporter.ReadHalfVector4(System.IO.BinaryReader)">
            <summary>
            Read HalfVector4
            </summary>
        </member>
        <member name="M:VRageRender.Import.MyModelImporter.ReadHalfVector2(System.IO.BinaryReader)">
            <summary>
            Read HalfVector2
            </summary>
        </member>
        <member name="M:VRageRender.Import.MyModelImporter.ReadByte4(System.IO.BinaryReader)">
            <summary>
            Read Byte4
            </summary>
        </member>
        <member name="M:VRageRender.Import.MyModelImporter.ImportVector3(System.IO.BinaryReader)">
            <summary>
            ImportVector3
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelImporter.ImportVector4(System.IO.BinaryReader)">
            <summary>
            ImportVector4
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelImporter.ImportQuaternion(System.IO.BinaryReader)">
            <summary>
            ImportQuaternion
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelImporter.ImportVector4Int(System.IO.BinaryReader)">
            <summary>
            ImportVector4Int
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelImporter.ImportVector3Int(System.IO.BinaryReader)">
            <summary>
            ImportVector3Int
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelImporter.ImportVector2(System.IO.BinaryReader)">
            <summary>
            ImportVector2
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelImporter.ReadArrayOfHalfVector4(System.IO.BinaryReader)">
            <summary>
            Read array of HalfVector4
            </summary>
        </member>
        <member name="M:VRageRender.Import.MyModelImporter.ReadArrayOfByte4(System.IO.BinaryReader)">
            <summary>
            Read array of Byte4
            </summary>
        </member>
        <member name="M:VRageRender.Import.MyModelImporter.ReadArrayOfHalfVector2(System.IO.BinaryReader)">
            <summary>
            Read array of HalfVector2
            </summary>
        </member>
        <member name="M:VRageRender.Import.MyModelImporter.ReadArrayOfVector3(System.IO.BinaryReader)">
            <summary>
            ReadArrayOfVector3
            </summary>
            <param name="br"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelImporter.ReadArrayOfVector4(System.IO.BinaryReader)">
            <summary>
            ReadArrayOfVector4
            </summary>
            <param name="br"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelImporter.ReadArrayOfVector4Int(System.IO.BinaryReader)">
            <summary>
            ReadArrayOfVector4
            </summary>
            <param name="br"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelImporter.ReadArrayOfVector3Int(System.IO.BinaryReader)">
            <summary>
            ReadArrayOfVector3I
            </summary>
            <param name="br"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelImporter.ReadArrayOfVector2(System.IO.BinaryReader)">
            <summary>
            ReadArrayOfVector2
            </summary>
            <param name="br"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelImporter.ReadArrayOfString(System.IO.BinaryReader)">
            <summary>
            ReadArrayOfString
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelImporter.ReadBoundingBox(System.IO.BinaryReader)">
            <summary>
            ReadBoundingBox
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelImporter.ReadBoundingSphere(System.IO.BinaryReader)">
            <summary>
            ReadBoundingSphere
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelImporter.ReadMatrix(System.IO.BinaryReader)">
            <summary>
            ReadMatrix
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelImporter.ReadMeshParts(System.IO.BinaryReader,System.Int32)">
            <summary>
            ReadMeshParts
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelImporter.ReadDummies(System.IO.BinaryReader)">
            <summary>
            ReadDummies
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelImporter.ReadArrayOfInt(System.IO.BinaryReader)">
            <summary>
            ReadArrayOfInt
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Import.MyModelImporter.LinearKeyframeReduction(System.Collections.Generic.LinkedList{VRageRender.Animations.MyAnimationClip.Keyframe},System.Single,System.Single)">
            <summary>
            This function filters out keyframes that can be approximated well with 
            linear interpolation.
            </summary>
            <param name="keyframes"></param>
        </member>
        <member name="T:VRageRender.VideoState">
            <summary>
            Describes the state of a video player
            </summary>
        </member>
        <member name="P:VRageRender.IMyRender.IsSupported">
            <summary>
            Must be possible to query during startup before render thread and window is created.
            </summary>
        </member>
        <member name="P:VRageRender.Messages.MyRenderMessageBase.MessageClass">
            <summary>
            Get message class
            </summary>
        </member>
        <member name="P:VRageRender.Messages.MyRenderMessageBase.MessageType">
            <summary>
            Gets message type
            </summary>
        </member>
        <member name="P:VRageRender.Messages.MySpriteDrawRenderMessage.MessageClass">
            <summary>If it has a target offscreen texture, then the message has to be processed earlier</summary>
        </member>
        <member name="T:VRageRender.Messages.MyRenderMessageUpdateRenderInstanceBufferRange">
            This is kinda your universal array operator splice().
            
            The only thing is we cannot move elements with this.
        </member>
        <member name="F:VRageRender.Messages.MyGeneratedTextureType.RGBA">
            <summary>sRGB</summary>
        </member>
        <member name="F:VRageRender.Messages.MyGeneratedTextureType.RGBA_Linear">
            <summary>Linear RGB</summary>
        </member>
        <member name="F:VRageRender.Messages.MyRenderMessageSetInstanceBuffer.InstanceData">
            <summary>
            Fill in only the relevant data. Data ouside of the specified range would not be used.
            </summary>
        </member>
        <member name="T:VRageRender.Messages.MyRenderMessageSwitchRenderSettings">
            <summary>
            1 at the end is naming convention from DX, saying this is newer version (for Dx11 render).
            </summary>
        </member>
        <member name="F:VRageRender.Messages.MyRenderMessageType.Draw">
            <summary>
            Draw message
            Skipped when renderer is falling behind and has to process multiple enqueued frames (only handled in last frame before draw)
            Draw sprite, Draw light
            </summary>
        </member>
        <member name="F:VRageRender.Messages.MyRenderMessageType.DebugDraw">
            <summary>
            Debug Draw message, in render11 these messages are queued internally
            Skipped when renderer is falling behind and has to process multiple enqueued frames (only handled in last frame before draw)
            Draw sprite, debug draw...
            </summary>
        </member>
        <member name="F:VRageRender.Messages.MyRenderMessageType.StateChangeOnce">
            <summary>
            State change which can be applied only once, not applied when rendering same frame second time or more
            Add render object, remove render object...
            </summary>
        </member>
        <member name="F:VRageRender.Messages.MyRenderMessageType.StateChangeEvery">
            <summary>
            State change which must be applied every time, even when drawing same frame multiple times
            Move render object, other interpolation messages
            </summary>
        </member>
        <member name="T:VRageRender.Messages.MyRenderMessageUpdateRenderEnvironment">
            <summary>
            The difference between environment and RenderSettings is that environment are game play values,
            on the other hand render settings are render internal/debugging values
            </summary>
        </member>
        <member name="M:VRageRender.Models.MyMesh.#ctor(VRageRender.Import.MyMeshPartInfo,System.String)">
            <summary>
            c-tor - generic way for collecting resources
            </summary>
            <param name="meshInfo"></param>
            assetName - just for debug output
        </member>
        <member name="P:VRageRender.MyDecalMaterial.Rotation">
            <summary>
            Positive infinity for random rotation
            </summary>
        </member>
        <member name="F:VRageRender.MyEnvironmentLightData.SunLightDirection">
            <summary>Direction FROM sun</summary>
        </member>
        <member name="F:VRageRender.MyFont.REPLACEMENT_CHARACTER">
            <summary>
            Replacement character shown when we don't have something in our texture.
            Normally, this would be \uFFFD, but BMFontGen refuses to generate it, so I put its glyph at \u25A1 (empty square)
            </summary>
        </member>
        <member name="F:VRageRender.MyFont.Spacing">
            <summary>
            This is artificial spacing in between two characters (in pixels).
            Using it we can make spaces wider or narrower
            </summary>
        </member>
        <member name="F:VRageRender.MyFont.KernEnabled">
            <summary>
            Enable / disable kerning of adjacent character pairs.
            </summary>
        </member>
        <member name="F:VRageRender.MyFont.Depth">
            <summary>
            The depth at which to draw the font
            </summary>
        </member>
        <member name="M:VRageRender.MyFont.#ctor(System.String,System.Int32)">
            <summary>
            Create a new font from the info in the specified font descriptor (XML) file
            </summary>
        </member>
        <member name="M:VRageRender.MyFont.LoadFontXML(System.Xml.XmlNodeList)">
            <summary>
            Load the font data from an XML font descriptor file
            </summary>
            <param name="xnl">XML node list containing the entire font descriptor file</param>
        </member>
        <member name="M:VRageRender.MyFont.LoadFontXML_font(System.Xml.XmlNodeList)">
            <summary>
            Load the data from the "font" node
            </summary>
            <param name="xnl">XML node list containing the "font" node's children</param>
        </member>
        <member name="M:VRageRender.MyFont.LoadFontXML_bitmaps(System.Xml.XmlNodeList)">
            <summary>
            Load the data from the "bitmaps" node
            </summary>
            <param name="xnl">XML node list containing the "bitmaps" node's children</param>
        </member>
        <member name="M:VRageRender.MyFont.LoadFontXML_glyphs(System.Xml.XmlNodeList)">
            <summary>
            Load the data from the "glyphs" node
            </summary>
            <param name="xnl">XML node list containing the "glyphs" node's children</param>
        </member>
        <member name="M:VRageRender.MyFont.LoadFontXML_kernpairs(System.Xml.XmlNodeList)">
            <summary>
            Load the data from the "kernpairs" node
            </summary>
            <param name="xnl">XML node list containing the "kernpairs" node's children</param>
        </member>
        <member name="M:VRageRender.MyFont.GetXMLAttribute(System.Xml.XmlNode,System.String)">
            <summary>
            Get the XML attribute value
            </summary>
            <param name="n">XML node</param>
            <param name="strAttr">Attribute name</param>
            <returns>Attribute value, or the empty string if the attribute doesn't exist</returns>
        </member>
        <member name="P:VRageRender.MyFont.Baseline">
            <summary>
            Distance from top of font to the baseline
            </summary>
        </member>
        <member name="P:VRageRender.MyFont.LineHeight">
            <summary>
            Distance from top to bottom of the font
            </summary>
        </member>
        <member name="T:VRageRender.MyFont.MyGlyphInfo">
            <summary>
             Info for each glyph in the font - where to find the glyph image and other properties
            </summary>
        </member>
        <member name="T:VRageRender.MyFont.MyBitmapInfo">
            <summary>
            Info for each font bitmap
            </summary>
        </member>
        <member name="T:VRageRender.MyMessagePool">
            <summary>
            TODO: This should use some better sync, it could introduce delays with current state
            1) Use spin lock
            2) Lock only queue, not whole dictionary
            3) Test count first and when it's insufficient, create new message, both should be safe to do out of any lock
            4) Custom consumer/producer non-locking (except resize) queue could be better (maybe overkill)
            </summary>
        </member>
        <member name="T:VRageRender.RenderFlags">
            <summary>
            Entity flags.
            </summary>
        </member>
        <member name="F:VRageRender.RenderFlags.SkipIfTooSmall">
            <summary>
            Skip the object in render if detected that it is too small
            </summary>
        </member>
        <member name="F:VRageRender.RenderFlags.NeedsResolveCastShadow">
            <summary>
            Needs resolve cast shadows flag (done by parallel raycast to sun)
            </summary>
        </member>
        <member name="F:VRageRender.RenderFlags.FastCastShadowResolve">
            <summary>
            Casts only one raycast to determine shadow casting
            </summary>
        </member>
        <member name="F:VRageRender.RenderFlags.CastShadows">
            <summary>
            Tells if this object should cast shadows
            </summary>
        </member>
        <member name="F:VRageRender.RenderFlags.Visible">
            <summary>
            Specifies whether draw this entity or not.
            </summary>
        </member>
        <member name="F:VRageRender.RenderFlags.DrawOutsideViewDistance">
            <summary>
            Specifies whether this entity should be drawn even when it is outside the set view distance
            </summary>
        </member>
        <member name="F:VRageRender.RenderFlags.Near">
            <summary>
            Specifies whether entity is "near", near entities are cockpit and weapons, these entities are rendered in special way
            </summary>
        </member>
        <member name="F:VRageRender.RenderFlags.UseCustomDrawMatrix">
            <summary>
            Tells if this object should use PlayerHeadMatrix as matrix for draw
            </summary>
        </member>
        <member name="F:VRageRender.RenderFlags.ShadowLodBox">
            <summary>
            Use local AABB box for shadow LOD, not used
            </summary>
        </member>
        <member name="F:VRageRender.RenderFlags.NoBackFaceCulling">
            <summary>
            No culling of back faces
            </summary>
        </member>
        <member name="T:VRageRender.LightTypeEnum">
            <summary>
            Light type, flags, could be combined
            </summary>
        </member>
        <member name="F:VRageRender.Lights.MyGlareTypeEnum.Normal">
            <summary>
            This is the glare that is dependent on occlusion queries.
            Physically, this phenomenon originates in the lens.
            </summary>
        </member>
        <member name="F:VRageRender.Lights.MyGlareTypeEnum.Distant">
            <summary>
            Sun
            </summary>
        </member>
        <member name="T:VRageRender.Textures.TextureQuality">
            <summary>
            Reresent loading quality for textures.
            This works only for dds textures with mipmaps. Other textures will retains their original properties.
            </summary>
        </member>
        <member name="F:VRageRender.Textures.TextureQuality.Full">
            <summary>
            Full quality.
            </summary>
        </member>
        <member name="F:VRageRender.Textures.TextureQuality.Half">
            <summary>
            1/2 quality.
            </summary>
        </member>
        <member name="F:VRageRender.Textures.TextureQuality.OneFourth">
            <summary>
            1/4 quality
            </summary>
        </member>
        <member name="F:VRageRender.Textures.TextureQuality.OneEighth">
            <summary>
            1/8 quality
            </summary>
        </member>
        <member name="F:VRageRender.Textures.TextureQuality.OneSixteenth">
            <summary>
            1/16 quality
            </summary>
        </member>
        <member name="P:VRageRender.Profiler.MyRenderProfilerRendering.ViewportSize">
            <summary>
            Returns viewport size in pixels
            </summary>
        </member>
        <member name="M:VRageRender.MyRenderProxy.DrawSprite(System.String,VRageMath.RectangleF@,System.Boolean,System.Nullable{VRageMath.Rectangle}@,VRageMath.Color,System.Single,VRageMath.Vector2,VRageMath.Vector2@,VRageRender.SpriteEffects,System.Single,System.Boolean,System.String)">
            <summary>
            
            </summary>
            <param name="texture">Texture name (path).</param>
            <param name="destination">Screen coord destination.</param>
            <param name="scaleDestination">NOT USED</param>
            <param name="sourceRectangle">Source rectangle in texture coordinates</param>
            <param name="color"></param>
            <param name="rotation">NOT USED</param>
            <param name="rightVector">Defines rotation around the origin. UnitX is 0 rotation.</param>
            <param name="origin">Origin of rotation in screen space coords.</param>
            <param name="effects">NOT USED</param>
            <param name="depth">NOT USED</param>
            <param name="waitTillLoaded"></param>
            <param name="targetTexture">NOT USED</param>
        </member>
        <member name="M:VRageRender.MyRenderProxy.DrawSprite(System.String,VRageMath.Vector2,VRageMath.Vector2,VRageMath.Color,VRage.Utils.MyGuiDrawAlignEnum,System.Single,VRageMath.Vector2,System.Single,System.Nullable{VRageMath.Vector2},System.Single,System.Boolean,System.String)">
            <summary>
            OBSOLETE: Used a lot in the old GUI and involves a lot of hacks to use the normalized coordinate system.
            Refactor would take too much time so its kept as is. Please consider using the Screen coord Sprite draw method instead.
            Its much cleaner and easier to use.
            </summary>
        </member>
        <member name="M:VRageRender.MyRenderProxy.IsValidGeneratedTextureName(System.String)">
            <returns>True if the texture name is valid and doesn't contant reserved characters</returns>
        </member>
        <member name="M:VRageRender.MyRenderProxy.CreateGeneratedTexture(System.String,System.Int32,System.Int32,VRageRender.Messages.MyGeneratedTextureType,System.Int32)">
            <returns>Qualified texture</returns>
        </member>
        <member name="M:VRageRender.MyRenderProxy.CreateRenderInstanceBuffer(System.String,VRageRender.Messages.MyRenderInstanceBufferType,System.UInt32)">
            <param name="parentId">Parent of the instance. Currently used for debugging. May be left unassingned</param>
        </member>
        <member name="M:VRageRender.MyRenderProxy.UpdateModelHighlight(System.UInt32,System.String[],System.UInt32[],System.Nullable{VRageMath.Color},System.Single,System.Single,System.Int32)">
            <param name="thickness">Zero or negative to remove highlight</param>
        </member>
        <member name="M:VRageRender.MyRenderProxy.UpdateHighlightOverlappingModel(System.UInt32,System.Boolean)">
            <summary>
            Makes the actor of given RenderId overlap highlights.
            If possible use MyHighlightSystem session component instead.
            </summary>
            <param name="modelRenderId">Actor Id.</param>
            <param name="enable">Enable flag.</param>
        </member>
        <member name="M:VRageRender.MyRenderProxy.ChangeModel(System.UInt32,System.String,System.Single)">
            <summary>
            New model should have similar size to previous model because of prunning structure recalculation
            </summary>
            <param name="id"></param>
            <param name="LOD"></param>
            <param name="model"></param>
            <param name="useForShadow"></param>
        </member>
        <member name="M:VRageRender.MyRenderProxy.RenderOffscreenTextureToMaterial(System.UInt32,System.String,System.String,System.Nullable{VRageMath.Color},VRageRender.Messages.MyTextureType)">
            <param name="backgroundColor">null means no background</param>
            <param name="blendAlphaChannel">Blend alpha channel</param>
        </member>
        <member name="M:VRageRender.MyRenderProxy.SetFrameTimeStep(System.Single)">
            <param name="timestep">Greter than zero: fixed timestep in seconds. If timestep is zero, the time step is computed</param>
        </member>
        <member name="T:VRageRender.MyRenderSettings">
            <summary>
            Settings for whole render. To make settings per draw, use RenderSetup
            </summary>
        </member>
        <member name="T:VRageRender.MyAntialiasingMode">
            <summary>
            VRage.Render11 only.
            </summary>
        </member>
        <member name="T:VRageRender.MyShadowsQuality">
            <summary>
            VRage.Render11 only.
            </summary>
        </member>
        <member name="T:VRageRender.MyTextureQuality">
            <summary>
            VRage.Render11 only.
            </summary>
        </member>
        <member name="T:VRageRender.MyTextureAnisoFiltering">
            <summary>
            VRage.Render11 only.
            </summary>
        </member>
        <member name="T:VRageRender.MyRenderSettings1">
            <summary>
            Naming convention from DX. Newer version for Dx11 render.
            Put only settings that player can control (either directly or indirectly) using options here.
            Don't put debug crap here!
            </summary>
        </member>
        <member name="T:VRageRender.Utils.MyRenderStats">
            <summary>
            Draws statistics
            </summary>
        </member>
        <member name="T:VRageRender.MySharedData">
            <summary>
            Data shared between render and update
            </summary>
        </member>
        <member name="M:VRageRender.MySharedData.BeforeUpdate">
            <summary>
            Refresh data from render (visible objects, render messages)
            </summary>
        </member>
        <member name="M:VRageRender.MyUpdateData.CommitUpdateFrame(ParallelTasks.SpinLockRef)">
            <summary>
            Commits current frame as atomic operation and prepares new frame
            </summary>
        </member>
        <member name="M:VRageRender.MyUpdateData.GetRenderFrame(System.Boolean@)">
            <summary>
            Gets next frame for rendering, can return null in case there's nothing for rendering (no update frame submitted).
            When isPreFrame is true, don't handle draw messages, just process update messages and call method again.
            Pre frame must release messages and must be returned.
            Final frame is kept unmodified in queue, in case of slower update, so we can interpolate and draw frame again.
            </summary>
        </member>
        <member name="M:VRageRender.MyUpdateData.ReturnPreFrame(VRageRender.MyUpdateFrame)">
            <summary>
            PreFrame must be empty in this place
            </summary>
        </member>
        <member name="T:VRageRender.MyUpdateFrame">
            <summary>
            Contains data produced by update frame, sent to render in thread-safe manner
            </summary>
        </member>
        <member name="T:VRageRender.SpriteEffects">
            <summary>
            Defines sprite mirroring options.
            </summary>
            <remarks>
            Description is taken from original XNA <a href='http://msdn.microsoft.com/en-us/library/VRageMath.graphics.spriteeffects.aspx'>SpriteEffects</a> class.
            </remarks>
        </member>
        <member name="F:VRageRender.SpriteEffects.None">
            <summary>
            No rotations specified.
            </summary>
        </member>
        <member name="F:VRageRender.SpriteEffects.FlipHorizontally">
            <summary>
            Rotate 180 degrees around the Y axis before rendering.
            </summary>
        </member>
        <member name="F:VRageRender.SpriteEffects.FlipVertically">
            <summary>
            Rotate 180 degrees around the X axis before rendering.
            </summary>
        </member>
        <member name="F:VRageRender.SpriteEffects.FlipBoth">
            <summary>
            Rotate 180 degress around both the X and Y axis before rendering.
            </summary>
        </member>
        <member name="T:VRageRender.SpriteScissorStack">
            <summary>
            Stores stack of scissor rectangles where top rectangle has already
            been cut using all the rectangles below it, so that only one
            rectangle is checked during scissor test.
            </summary>
        </member>
        <member name="M:VRageRender.SpriteScissorStack.Cut(VRageMath.RectangleF@,VRageMath.RectangleF@)">
            <summary>
            Cuts the destination rectangle using top of the scissor stack.
            Source rectangle is modified using scaled change of destination
            as well.
            </summary>
        </member>
        <member name="M:VRageRender.Utils.MyWingedEdgeMesh.Copy">
            <summary>
            For testing purposes only! The copy is only a shallow copy (i.e. userdata is not copied)
            </summary>
        </member>
        <member name="M:VRageRender.Utils.MyWingedEdgeMesh.MakeEdgeFace(System.Int32,System.Int32,System.Int32,System.Int32,System.Object,System.Int32@)">
            <summary>
            Creates a new face by closing the gap between vertices vert1 and vert2 by a new edge
            </summary>
            <param name="vert1">Point that will be shared by the new edge and edge1</param>
            <param name="vert2">Point that will be shared by the new edge and edge2</param>
            <param name="edge1">Predecessor of the new edge</param>
            <param name="edge2">Successor of the new edge</param>
            <param name="faceUserData">User data for the newly created face</param>
        </member>
        <member name="M:VRageRender.Utils.MyWingedEdgeMesh.MergeEdges(System.Int32,System.Int32)">
            <summary>
            Merges two edges together into one. These edges have to border on the edge of the mesh (i.e. face -1)
            Note that this also merges the corresponding vertices!
            </summary>
            <param name="edge1">The edge that will be merged</param>
            <param name="edge2">The edge that will be kept</param>
        </member>
        <member name="M:VRageRender.Utils.MyWingedEdgeMesh.ExtrudeTriangleFromEdge(VRageMath.Vector3@,System.Int32,System.Object,System.Int32@,System.Int32@)">
            <summary>
            Creates a new triangle by adding a vertex to an existing edge
            </summary>
            <param name="newVertex">Position of the new vertex</param>
            <param name="edge">The edge from which we want to extrude</param>
            <param name="faceUserData">User data that will be saved in the face</param>
            <param name="newEdgeS">Index of the new edge that follows edge "edge" in the new triangle.</param>
            <param name="newEdgeP">Index of the new edge that precedes edge "edge" in the new triangle.</param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Utils.MyWingedEdgeMesh.MakeFace(System.Object,System.Int32)">
            <summary>
            Makes a face by filling in the empty edge loop incident to incidentEdge
            </summary>
            <param name="userData"></param>
            <param name="incidentEdge"></param>
            <returns></returns>
        </member>
        <member name="M:VRageRender.Utils.MyWingedEdgeMesh.SortFreeFaces">
            <summary>
            Sorts the list of free faces. This ensures that subsequent face allocations will return increasing sequence of face indices,
            unless interrupted by face deallocation. This can be useful in some algorithms that rely on ordering of the face indices.
            </summary>
        </member>
        <member name="M:VRageRender.Utils.MyWingedEdgeMesh.CheckFreeEntryConsistency">
            <summary>
            Checks for loops in the meshe's tables' freed entries
            </summary>
        </member>
        <member name="M:VRageRender.Utils.MyWingedEdgeMesh.EdgeTableEntry.TryGetSharedVertex(VRageRender.Utils.MyWingedEdgeMesh.EdgeTableEntry@)">
            <summary>
            Returns -1 if there is no shared edge
            </summary>
        </member>
        <member name="M:VRageRender.Utils.MyWingedEdgeMesh.EdgeTableEntry.VertexLeftFace(System.Int32)">
            <summary>
            Returns a face to the left when going towards the given vertex
            </summary>
        </member>
        <member name="M:VRageRender.Utils.MyWingedEdgeMesh.EdgeTableEntry.VertexRightFace(System.Int32)">
            <summary>
            Returns a face to the right when going towards the given vertex
            </summary>
        </member>
        <member name="M:VRageRender.Utils.MyWingedEdgeMesh.EdgeTableEntry.FaceSucc(System.Int32)">
            <summary>
            Returns the successor of this edge in the given face
            </summary>
        </member>
        <member name="M:VRageRender.Utils.MyWingedEdgeMesh.EdgeTableEntry.SetFaceSucc(System.Int32,System.Int32)">
            <summary>
            Sets the successor of this edge in the given face
            </summary>
        </member>
        <member name="M:VRageRender.Utils.MyWingedEdgeMesh.EdgeTableEntry.FacePred(System.Int32)">
            <summary>
            Returns the predecessor of this edge in the given face
            </summary>
        </member>
        <member name="M:VRageRender.Utils.MyWingedEdgeMesh.EdgeTableEntry.SetFacePred(System.Int32,System.Int32)">
            <summary>
            Sets the predecessor of this edge in the given face
            </summary>
        </member>
        <member name="M:VRageRender.Utils.MyWingedEdgeMesh.EdgeTableEntry.VertexSucc(System.Int32)">
            <summary>
            Gets the successor around the given vertex.
            </summary>
        </member>
        <member name="M:VRageRender.Utils.MyWingedEdgeMesh.EdgeTableEntry.SetVertexSucc(System.Int32,System.Int32)">
            <summary>
            Sets the successor around the given vertex.
            </summary>
            <returns>The old successor value</returns>
        </member>
        <member name="M:VRageRender.Utils.MyWingedEdgeMesh.EdgeTableEntry.VertexPred(System.Int32)">
            <summary>
            Gets the predecessor around the given vertex
            </summary>
        </member>
        <member name="M:VRageRender.Utils.MyWingedEdgeMesh.EdgeTableEntry.SetVertexPred(System.Int32,System.Int32)">
            <summary>
            Sets the predecessor around the given vertex.
            </summary>
            <returns>The old predecessor value</returns>
        </member>
        <member name="P:VRageRender.Utils.MyWingedEdgeMesh.EdgeTableEntry.NextFreeEntry">
            <summary>
            Only valid for empty (deallocated) table entries. In that case, it points to the next free table entry.
            If this is -1, this entry is the last free entry.
            </summary>
        </member>
        <member name="P:VRageRender.Utils.MyWingedEdgeMesh.VertexTableEntry.NextFreeEntry">
            <summary>
            Only valid for empty (deallocated) table entries. In that case, it points to the next free table entry.
            If this is -1, this entry is the last free entry.
            </summary>
        </member>
        <member name="P:VRageRender.Utils.MyWingedEdgeMesh.FaceTableEntry.NextFreeEntry">
            <summary>
            Only valid for empty (deallocated) table entries. In that case, it points to the next free table entry.
            If this is -1, this entry is the last free entry.
            </summary>
        </member>
        <member name="T:VRageRender.Utils.MyWingedEdgeMesh.Edge">
            <summary>
            Note: This is invalid after the mesh changes!
            </summary>
        </member>
        <member name="T:VRageRender.Utils.MyWingedEdgeMesh.Face">
            <summary>
            Note: This is invalid after the mesh changes!
            </summary>
        </member>
        <member name="T:VRageRender.Utils.MyWingedEdgeMesh.VertexEdgeEnumerator">
            <summary>
            Note: This is invalid after the mesh changes!
            </summary>
        </member>
        <member name="T:VRageRender.Utils.MyWingedEdgeMesh.FaceEdgeEnumerator">
            <summary>
            Note: This is invalid after the mesh changes!
            </summary>
        </member>
        <member name="T:VRageRender.Utils.MyWingedEdgeMesh.FaceVertexEnumerator">
            <summary>
            Note: This is invalid after the mesh changes!
            </summary>
        </member>
        <member name="T:VRageRender.Utils.MyWingedEdgeMesh.EdgeEnumerator">
            <summary>
            Note: This is invalid after the mesh changes!
            </summary>
        </member>
        <member name="M:VRageRender.Voxels.MyClipmap.InvalidateRange(VRageMath.Vector3I,VRageMath.Vector3I)">
            <param name="minCellLod0">Inclusive.</param>
            <param name="maxCellLod0">Inclusive.</param>
        </member>
        <member name="M:VRageRender.Voxels.MyClipmap.LodLevel.WasAncestorCellLoaded(VRageRender.Voxels.MyClipmap.LodLevel,VRage.Voxels.MyCellCoord@)">
            <summary>
            Checks ancestor nodes recursively.
            </summary>
        </member>
        <member name="M:VRageRender.Voxels.MyClipmap.LodLevel.ChildrenWereLoaded(VRageRender.Voxels.MyClipmap.LodLevel,VRage.Voxels.MyCellCoord@)">
            <summary>
            Checks only immediate children (any deeper would take too long).
            </summary>
        </member>
    </members>
</doc>
